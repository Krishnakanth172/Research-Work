# -*- coding: utf-8 -*-
"""UpdatedQCS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HDCKzD7K8FDtnlOz8tk6hwYzwKRyiIuj
"""

!pip install pennylane chembl-webresource-client rdkit matplotlib

import pennylane as qml
from pennylane import numpy as np
from chembl_webresource_client.new_client import new_client
from rdkit import Chem
from rdkit.Chem import AllChem, Draw
import matplotlib.pyplot as plt

# Fetch molecular data with no Rule-of-5 violations
molecule = new_client.molecule
molecule_list = molecule.filter(
    molecule_properties__num_ro5_violations=0
).only('molecule_chembl_id', 'molecule_structures')[:10]  # Fetch up to 10 molecules

# Extract SMILES strings and convert to RDKit molecular objects
smiles_list = [mol['molecule_structures']['canonical_smiles'] for mol in molecule_list]
rdkit_molecules = [Chem.MolFromSmiles(smile) for smile in smiles_list]

# Visualize up to 10 molecules
plt.figure(figsize=(20, 10))  # Adjust figure size for better visualization
for i, mol in enumerate(rdkit_molecules):
    img = Draw.MolToImage(mol, size=(300, 300))  # Create image for each molecule
    plt.subplot(2, 5, i + 1)  # Arrange in a 2x5 grid
    plt.imshow(img)
    plt.title(f"Molecule {i + 1}", fontsize=12)
    plt.axis('off')
plt.tight_layout()
plt.show()

def generate_hamiltonian(molecule):
    # Add hydrogens and optimize geometry
    molecule = Chem.AddHs(molecule)
    AllChem.EmbedMolecule(molecule)
    AllChem.UFFOptimizeMolecule(molecule)

    # For simplicity, assume a basic Hamiltonian representation using Pauli matrices
    num_qubits = 4  # Increase number of qubits to represent a more complex molecule

    # Define Pauli matrices
    X = qml.PauliX
    Y = qml.PauliY
    Z = qml.PauliZ

    # Example Hamiltonian as a sum of Pauli matrices
    hamiltonian = (
        1.0 * X(0) @ Z(1) +
        0.5 * Y(2) @ Z(3) +
        0.3 * Z(0) @ X(2)
    )

    return num_qubits, hamiltonian

def run_vqe(num_qubits, hamiltonian):
    # Define the quantum device
    dev = qml.device('default.qubit', wires=num_qubits)

    # Define a variational ansatz (quantum circuit)
    @qml.qnode(dev)
    def circuit(params):
        # Create a simple parameterized circuit
        for i in range(num_qubits):
            qml.RX(params[i], wires=i)  # RX gates as part of the ansatz
        qml.Hadamard(wires=0)
        qml.CNOT(wires=[0, 1])
        # Apply the Hamiltonian (sum of Pauli matrices)
        return qml.expval(hamiltonian)  # Return expectation value of the Hamiltonian

    # Initialize parameters for the ansatz
    params = np.random.uniform(0, 2 * np.pi, num_qubits)

    # Classical optimizer (Gradient Descent)
    opt = qml.GradientDescentOptimizer(stepsize=0.1)

    # Run the VQE optimization loop
    for step in range(100):  # Run for 100 steps
        params, energy = opt.step_and_cost(circuit, params)
        if step % 10 == 0:
            print(f"Step {step}: Energy = {energy}")

    return energy

# Analyze multiple molecules with VQE
for i, mol in enumerate(rdkit_molecules[:3]):  # Analyze the first 3 molecules
    print(f"\nAnalyzing molecule {i + 1}:")
    num_qubits, hamiltonian = generate_hamiltonian(mol)
    energy = run_vqe(num_qubits, hamiltonian)
    print(f"Estimated Ground State Energy for molecule {i + 1}: {energy}")

import matplotlib.pyplot as plt
import numpy as np

# Extend the Analysis to More Molecules
# Let's analyze the first 10 molecules instead of just 3
num_molecules = 10
for i, mol in enumerate(rdkit_molecules[:num_molecules]):
    print(f"\nAnalyzing molecule {i + 1}:")
    num_qubits, hamiltonian = generate_hamiltonian(mol)
    energy = run_vqe(num_qubits, hamiltonian)
    print(f"Estimated Ground State Energy for molecule {i + 1}: {energy}")

# Step 2: Compare Quantum and Classical Methods
# You can compare the results of quantum methods (VQE) with classical methods
# For classical methods, you might need to use libraries like PySCF or QChem to calculate energies
# For now, let's assume you have a function `get_classical_energy()` that returns the classical energy
def get_classical_energy(molecule):
    # Placeholder for classical energy calculation (e.g., using PySCF or DFT)
    return -1.45  # Example value

# Compare energies
quantum_energies = []
classical_energies = []

for i, mol in enumerate(rdkit_molecules[:num_molecules]):
    num_qubits, hamiltonian = generate_hamiltonian(mol)
    quantum_energy = run_vqe(num_qubits, hamiltonian)
    classical_energy = get_classical_energy(mol)

    quantum_energies.append(quantum_energy)
    classical_energies.append(classical_energy)

    print(f"Comparison for molecule {i + 1}:")
    print(f"Quantum Energy: {quantum_energy}")
    print(f"Classical Energy: {classical_energy}")

# Step 3: Visualize Quantum vs Classical Energies
plt.figure(figsize=(10, 6))
x = np.arange(num_molecules)
width = 0.35

plt.bar(x - width/2, quantum_energies, width, label='Quantum Energy', color='blue')
plt.bar(x + width/2, classical_energies, width, label='Classical Energy', color='green')

plt.xlabel('Molecule Index')
plt.ylabel('Energy')
plt.title('Quantum vs Classical Ground State Energy')
plt.xticks(x, [f'Mol {i + 1}' for i in range(num_molecules)])
plt.legend()
plt.tight_layout()
plt.show()

# Step 4: Error Analysis (Optional)
# This can involve plotting the error between the quantum and classical results for each molecule
errors = np.array(quantum_energies) - np.array(classical_energies)
plt.figure(figsize=(10, 6))
plt.bar(x, errors, color='red', alpha=0.7)
plt.xlabel('Molecule Index')
plt.ylabel('Energy Difference (Quantum - Classical)')
plt.title('Error Analysis: Quantum vs Classical Energy')
plt.xticks(x, [f'Mol {i + 1}' for i in range(num_molecules)])
plt.tight_layout()
plt.show()