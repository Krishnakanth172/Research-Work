# -*- coding: utf-8 -*-
"""Fidelity1QCS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ulmWGR49NApOFP21zHXEA6T-iIqj3elC
"""

!pip install pennylane chembl-webresource-client rdkit

import pennylane as qml
from pennylane import numpy as np
from chembl_webresource_client.new_client import new_client
from rdkit import Chem
from rdkit.Chem import AllChem, Draw
import matplotlib.pyplot as plt

# Fetch molecular data with no Rule-of-5 violations
molecule = new_client.molecule
molecule_list = molecule.filter(
    molecule_properties__num_ro5_violations=0
).only('molecule_chembl_id', 'molecule_structures')[:10]  # Fetch up to 10 molecules

# Extract SMILES strings and convert to RDKit molecular objects
smiles_list = [mol['molecule_structures']['canonical_smiles'] for mol in molecule_list]
rdkit_molecules = [Chem.MolFromSmiles(smile) for smile in smiles_list]

# Visualize up to 10 molecules
plt.figure(figsize=(20, 10))  # Adjust figure size for better visualization
for i, mol in enumerate(rdkit_molecules):
    img = Draw.MolToImage(mol, size=(300, 300))  # Create image for each molecule
    plt.subplot(2, 5, i + 1)  # Arrange in a 2x5 grid
    plt.imshow(img)
    plt.title(f"Molecule {i + 1}", fontsize=12)
    plt.axis('off')
plt.tight_layout()
plt.show()

def generate_hamiltonian(molecule):
    # Add hydrogens and optimize geometry
    molecule = Chem.AddHs(molecule)
    AllChem.EmbedMolecule(molecule)
    AllChem.UFFOptimizeMolecule(molecule)

    # Define a dummy Hamiltonian (2-qubit example)
    num_qubits = 2
    hamiltonian = np.array([[1.0, 0.0, 0.0, 0.0],
                            [0.0, -1.0, 0.0, 0.0],
                            [0.0, 0.0, 1.0, 0.0],
                            [0.0, 0.0, 0.0, -1.0]])
    return num_qubits, hamiltonian

# Generate Hamiltonian for the first molecule
num_qubits, hamiltonian = generate_hamiltonian(rdkit_molecules[0])
print(f"Number of qubits: {num_qubits}")
print(f"Hamiltonian:\n{hamiltonian}")

def run_quantum_simulation(num_qubits, hamiltonian):
    # Initialize quantum device
    dev = qml.device('default.qubit', wires=num_qubits)

    # Define quantum circuit
    @qml.qnode(dev)
    def circuit():
        qml.Hadamard(wires=0)
        qml.CNOT(wires=[0, 1])
        qml.QubitUnitary(hamiltonian, wires=range(num_qubits))
        return qml.probs(wires=range(num_qubits))

    # Run simulation
    probabilities = circuit()
    return probabilities

# Run simulation and display results
probabilities = run_quantum_simulation(num_qubits, hamiltonian)
print("Quantum state probabilities:", probabilities)

# Plot the probabilities
def plot_probabilities(probabilities):
    plt.bar(range(len(probabilities)), probabilities, color='blue', alpha=0.7)
    plt.xlabel("Quantum States")
    plt.ylabel("Probability")
    plt.title("Quantum State Probabilities")
    plt.xticks(range(len(probabilities)), [f"|{i:02b}⟩" for i in range(len(probabilities))])
    plt.show()

plot_probabilities(probabilities)

# Analyze multiple molecules
for i, mol in enumerate(rdkit_molecules[:3]):  # Analyze the first 3 molecules
    print(f"\nAnalyzing molecule {i + 1}:")
    num_qubits, hamiltonian = generate_hamiltonian(mol)
    probabilities = run_quantum_simulation(num_qubits, hamiltonian)
    print(f"Probabilities for molecule {i + 1}: {probabilities}")
    plot_probabilities(probabilities)

import numpy as np
import matplotlib.pyplot as plt
# Classical simulation of quantum operations
def classical_simulation(hamiltonian):
    # Start with the state |00⟩ (initial quantum state)
    state = np.array([1.0, 0.0, 0.0, 0.0])

    # Apply Hadamard gate on qubit 0 (state |0⟩ -> (|0⟩ + |1⟩)/sqrt(2))
    H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
    state = np.kron(H, np.eye(2)) @ state

    # Apply CNOT gate (control qubit 0, target qubit 1)
    CNOT = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])
    state = CNOT @ state

    # Apply Hamiltonian (for this example, it's a simple 2-qubit Hamiltonian)
    state = np.dot(hamiltonian, state)

    # Normalize the state
    state /= np.linalg.norm(state)
    return state

# Quantum simulation (using PennyLane)
import pennylane as qml

def quantum_simulation(num_qubits, hamiltonian):
    # Initialize quantum device
    dev = qml.device('default.qubit', wires=num_qubits)

    # Define quantum circuit
    @qml.qnode(dev)
    def circuit():
        qml.Hadamard(wires=0)
        qml.CNOT(wires=[0, 1])
        qml.QubitUnitary(hamiltonian, wires=range(num_qubits))
        return qml.probs(wires=range(num_qubits))

    # Run simulation
    probabilities = circuit()
    return probabilities

# Fidelity Calculation (compares two quantum state vectors, not just probabilities)
def calculate_fidelity(state_1, state_2):
    # Fidelity is the squared magnitude of the inner product between the two states
    inner_product = np.dot(state_1.conj(), state_2)
    return np.abs(inner_product) ** 2

# Classical simulation should output a full state vector (not just probabilities)
def classical_simulation(hamiltonian):
    # Start with the state |00⟩ (initial quantum state)
    state = np.array([1.0, 0.0, 0.0, 0.0])

    # Apply Hadamard gate on qubit 0 (state |0⟩ -> (|0⟩ + |1⟩)/sqrt(2))
    H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
    state = np.kron(H, np.eye(2)) @ state

    # Apply CNOT gate (control qubit 0, target qubit 1)
    CNOT = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])
    state = CNOT @ state

    # Apply Hamiltonian (for this example, it's a simple 2-qubit Hamiltonian)
    state = np.dot(hamiltonian, state)

    # Normalize the state
    state /= np.linalg.norm(state)
    return state

# Quantum simulation
def quantum_simulation(num_qubits, hamiltonian):
    # Initialize quantum device
    dev = qml.device('default.qubit', wires=num_qubits)

    # Define quantum circuit
    @qml.qnode(dev)
    def circuit():
        qml.Hadamard(wires=0)
        qml.CNOT(wires=[0, 1])
        qml.QubitUnitary(hamiltonian, wires=range(num_qubits))
        return qml.state()

    # Run simulation
    state = circuit()
    return state

# Now compute fidelity using the full state vectors
classical_state = classical_simulation(hamiltonian)
quantum_state = quantum_simulation(num_qubits, hamiltonian)

# Calculate fidelity between full state vectors
fidelity = calculate_fidelity(classical_state, quantum_state)

# Output results
print("Classical simulation state:", classical_state)
print("Quantum simulation state:", quantum_state)
print("Fidelity between classical and quantum states:", fidelity)

def overlap(state1, state2):
    return np.abs(np.dot(state1.conj(), state2))

overlap_value = overlap(classical_state, quantum_state)
print(f"Overlap: {overlap_value}")

# Compute metrics, taking only the real part of quantum state to avoid complex warnings
tvd = total_variation_distance(classical_state, np.real(quantum_state))
cosine_sim = cosine_similarity(classical_state, np.real(quantum_state))

print(f"Total Variation Distance: {tvd}")
print(f"Cosine Similarity: {cosine_sim}")

import numpy as np
from scipy.linalg import sqrtm

def quantum_fidelity(mixed_state_1, mixed_state_2):
    # Compute the square roots of the density matrices
    sqrt_rho1 = sqrtm(mixed_state_1)
    sqrt_rho2 = sqrtm(mixed_state_2)

    # Compute the fidelity
    fidelity_matrix = np.dot(np.dot(sqrt_rho1, mixed_state_2), sqrt_rho1)
    fidelity = np.trace(sqrtm(fidelity_matrix)) ** 2
    return fidelity

# Define two mixed states (density matrices)
mixed_state_1 = np.array([[0.5, 0.0], [0.0, 0.5]])  # Example density matrix
mixed_state_2 = np.array([[0.5, 0.0], [0.0, 0.5]])  # Example density matrix

# Calculate the fidelity between the two mixed states
fidelity = quantum_fidelity(mixed_state_1, mixed_state_2)
print(f"Quantum Fidelity: {fidelity}")

import numpy as np

def energy_comparison(hamiltonian, state):
    """
    Compute the expectation value of the Hamiltonian for a given quantum state.

    Args:
    - hamiltonian: The Hamiltonian matrix (2D numpy array)
    - state: The quantum state vector (1D numpy array)

    Returns:
    - Energy: The expectation value of the Hamiltonian for the quantum state
    """
    # Compute the energy by calculating the expectation value of the Hamiltonian
    energy = np.real(np.dot(state.conj().T, np.dot(hamiltonian, state)))
    return energy

# Example usage:
# Define a Hamiltonian matrix (2x2 for simplicity)
hamiltonian = np.array([[1.0, 0.0], [0.0, -1.0]])  # Example Hamiltonian matrix

# Define a quantum state (pure state as a vector)
quantum_state = np.array([1, 0])  # Example quantum state (pure state)

# Compute the energy expectation value for the quantum state
energy = energy_comparison(hamiltonian, quantum_state)
print(f"Energy Comparison: {energy}")

import numpy as np
import matplotlib.pyplot as plt

# Results from the evaluations
metrics = {
    "Energy Comparison": 1.0,
    "Quantum Fidelity": 1.0,
    "Cosine Similarity": 1.0,
    "TVD": 1.0,
    "Overlap": 0.9999999
}

# Function to create a radar chart
def plot_radar_chart(metrics):
    # Number of metrics
    labels = list(metrics.keys())
    values = list(metrics.values())

    # Number of variables
    num_vars = len(labels)

    # Compute angle for each axis
    angles = np.linspace(0, 2 * np.pi, num_vars, endpoint=False).tolist()

    # Make the radar chart a circle by appending the first value to the end
    values += values[:1]
    angles += angles[:1]

    # Create the radar chart
    fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))

    # Plot the area and the line for the chart
    ax.fill(angles, values, color='midnightblue', alpha=0.7)  # Filling with a deep blue color
    ax.plot(angles, values, color='darkorange', linewidth=3)  # Line with a bright color to stand out

    # Set the labels and titles
    ax.set_yticklabels([])  # Remove radial ticks
    ax.set_xticks(angles[:-1])  # Set the angular ticks
    ax.set_xticklabels(labels, fontsize=14, fontweight='bold', color='darkviolet')  # Customizing label style

    # Add title
    ax.set_title("Quantum Simulation Evaluation Metrics", fontsize=18, fontweight='bold', color='darkblue', va='bottom')

    # Add gridlines for better readability
    ax.grid(color='gray', linestyle='--', linewidth=0.5)

    # Display the chart
    plt.tight_layout()
    plt.show()

# Call the function to plot
plot_radar_chart(metrics)