# -*- coding: utf-8 -*-
"""QCSimp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r_0n19B_bjqESmpL0yZhdOW24eletTzn
"""

!pip install pennylane chembl-webresource-client rdkit

import pennylane as qml
from pennylane import numpy as np
from chembl_webresource_client.new_client import new_client
from rdkit import Chem
from rdkit.Chem import AllChem, Draw
import matplotlib.pyplot as plt

# Fetch molecular data with Lipinski's Rule of 5 from ChemBL Database
molecule = new_client.molecule
molecule_list = molecule.filter(
    molecule_properties__num_ro5_violations=0
).only('molecule_chembl_id', 'molecule_structures')[:10]

# Extract SMILES strings and convert to RDKit molecular objects
smiles_list = [mol['molecule_structures']['canonical_smiles'] for mol in molecule_list]
rdkit_molecules = [Chem.MolFromSmiles(smile) for smile in smiles_list]

# Visualize up to 10 molecules
plt.figure(figsize=(20, 10))
for i, mol in enumerate(rdkit_molecules):
    img = Draw.MolToImage(mol, size=(300, 300))
    plt.subplot(2, 5, i + 1)
    plt.imshow(img)
    plt.title(f"Molecule {i + 1}", fontsize=12)
    plt.axis('off')
plt.tight_layout()
plt.show()

# Hamiltonian generation
def generate_hamiltonian(molecule):
    # Add hydrogens and optimize geometry
    molecule = Chem.AddHs(molecule)
    AllChem.EmbedMolecule(molecule)
    AllChem.UFFOptimizeMolecule(molecule)

    # Define a dummy Hamiltonian (2-qubit example)
    num_qubits = 2
    hamiltonian = np.array([[1.0, 0.0, 0.0, 0.0],
                            [0.0, -1.0, 0.0, 0.0],
                            [0.0, 0.0, 1.0, 0.0],
                            [0.0, 0.0, 0.0, -1.0]])
    return num_qubits, hamiltonian

# Generate Hamiltonian for the first molecule
num_qubits, hamiltonian = generate_hamiltonian(rdkit_molecules[0])
print(f"Number of qubits: {num_qubits}")
print(f"Hamiltonian:\n{hamiltonian}")

# Quantum simualtion using Pennylane

def run_quantum_simulation(num_qubits, hamiltonian):
    # Initialize quantum device
    dev = qml.device('default.qubit', wires=num_qubits)

    # Define quantum circuit
    @qml.qnode(dev)
    def circuit():
        qml.Hadamard(wires=0)
        qml.CNOT(wires=[0, 1])
        qml.QubitUnitary(hamiltonian, wires=range(num_qubits))
        return qml.probs(wires=range(num_qubits))

    # Run simulation
    probabilities = circuit()
    return probabilities

# Run simulation and display results
probabilities = run_quantum_simulation(num_qubits, hamiltonian)
print("Quantum state probabilities:", probabilities)

# Plot the probabilities
def plot_probabilities(probabilities):
    plt.bar(range(len(probabilities)), probabilities, color='blue', alpha=0.7)
    plt.xlabel("Quantum States")
    plt.ylabel("Probability")
    plt.title("Quantum State Probabilities")
    plt.xticks(range(len(probabilities)), [f"|{i:02b}⟩" for i in range(len(probabilities))])
    plt.show()

plot_probabilities(probabilities)

# Fidelity Calculation (compares two quantum state vectors, not just probabilities)
def calculate_fidelity(state_1, state_2):
    inner_product = np.dot(state_1.conj(), state_2)
    return np.abs(inner_product) ** 2

# Classical simulation
def classical_simulation(hamiltonian):
    # Start with the state |00⟩ (initial quantum state)
    state = np.array([1.0, 0.0, 0.0, 0.0])

    # Apply Hadamard gate on qubit 0 (state |0⟩ -> (|0⟩ + |1⟩)/sqrt(2))
    H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
    state = np.kron(H, np.eye(2)) @ state

    # Apply CNOT gate (control qubit 0, target qubit 1)
    CNOT = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])
    state = CNOT @ state

    # Apply Hamiltonian
    state = np.dot(hamiltonian, state)

    # Normalize the state
    state /= np.linalg.norm(state)
    return state

# Quantum simulation
def quantum_simulation(num_qubits, hamiltonian):
    # Initialize quantum device
    dev = qml.device('default.qubit', wires=num_qubits)

    # Define quantum circuit
    @qml.qnode(dev)
    def circuit():
        qml.Hadamard(wires=0)
        qml.CNOT(wires=[0, 1])
        qml.QubitUnitary(hamiltonian, wires=range(num_qubits))
        return qml.state()

    # Run simulation
    state = circuit()
    return state

# Now compute fidelity using the full state vectors
classical_state = classical_simulation(hamiltonian)
quantum_state = quantum_simulation(num_qubits, hamiltonian)

# Calculate fidelity between full state vectors
fidelity = calculate_fidelity(classical_state, quantum_state)

# Output results
print("Classical simulation state:", classical_state)
print("Quantum simulation state:", quantum_state)
print("Fidelity between classical and quantum states:", fidelity)

def overlap(state1, state2):
    return np.abs(np.dot(state1.conj(), state2))

overlap_value = overlap(classical_state, quantum_state)
print(f"Overlap: {overlap_value}")

import numpy as np

def total_variation_distance(p, q):
    return 0.5 * np.sum(np.abs(p - q))

def cosine_similarity(a, b):
    dot_product = np.dot(a, b)
    norm_a = np.linalg.norm(a)
    norm_b = np.linalg.norm(b)

    # Prevent division by zero
    if norm_a == 0 or norm_b == 0:
        raise ValueError("One of the vectors is zero, cannot compute cosine similarity.")

    return dot_product / (norm_a * norm_b)

# Actual data
classical_state = np.array([0.70710678, 0.0, 0.0, -0.70710678])
quantum_state = np.array([0.70710678+0.j, 0.0+0.j, 0.0+0.j, -0.70710678+0.j])

# Compute the metrics
tvd = total_variation_distance(classical_state, np.real(quantum_state))
cosine_sim = cosine_similarity(classical_state, np.real(quantum_state))

# Display the results
print(f"Total Variation Distance: {tvd}")
print(f"Cosine Similarity: {cosine_sim}")

import numpy as np
from scipy.linalg import sqrtm

def quantum_fidelity(mixed_state_1, mixed_state_2):
    sqrt_rho1 = sqrtm(mixed_state_1)
    sqrt_rho2 = sqrtm(mixed_state_2)

    fidelity_matrix = np.dot(np.dot(sqrt_rho1, mixed_state_2), sqrt_rho1)
    fidelity = np.trace(sqrtm(fidelity_matrix)) ** 2
    return fidelity

mixed_state_1 = np.array([[0.6, 0.2], [0.2, 0.4]])
mixed_state_2 = np.array([[0.7, 0.1], [0.1, 0.3]])

fidelity = quantum_fidelity(mixed_state_1, mixed_state_2)
print(f"Quantum Fidelity: {fidelity}")

import numpy as np

def energy_comparison(hamiltonian, state):
    energy = np.real(np.dot(state.conj().T, np.dot(hamiltonian, state)))
    return energy

hamiltonian = np.array([[0.8, 0.3], [0.3, -0.5]])

quantum_state = np.array([0.6 + 0.0j, 0.8 + 0.0j])

energy = energy_comparison(hamiltonian, quantum_state)
print(f"Energy Comparison: {energy}")